<?php
/**
 * @file
 * This module allows webforms to have a start and end date for their
 * submissions.
 *
 * @author Daniel Imhoff
 */

/**
 * Implements hook_permission().
 */
function webform_scheduler_permission() {
  return array(
    'schedule webforms' => array(
      'title' => t('Schedule webforms'),
      'description' => t('Change a webform\'s start and end date, allowing a webform to be scheduled.'),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for webform_configure_form().
 */
function webform_scheduler_form_webform_configure_form_alter(&$form, &$form_state) {
  if (user_access('schedule webforms')) {
    $scheduler_settings = _webform_scheduler_webform_scheduler_settings($form['#node']->nid);

    $form['#validate'][] = 'webform_scheduler_form_webform_configure_form_validate';
    $form['#submit'][] = 'webform_scheduler_form_webform_configure_form_submit';

    $format = _webform_scheduler_date_format();

    $now = new DateObject();
    $now_formatted = $now->format($format);

    if (!empty($scheduler_settings)) {
      $start_date = $scheduler_settings['begin'] != 0 ? new DateObject($scheduler_settings['begin']) : NULL;
      $end_date = $scheduler_settings['end'] != 0 ? new DateObject($scheduler_settings['end']) : NULL;
    }

    $form['scheduler'] = array(
      '#type' => 'fieldset',
      '#title' => t('Scheduler'),
      '#description' => t('Specify dates and times to schedule when users are allowed to use this webform. Leave blank to disable this feature.'),
      '#weight' => -2.5,
      '#collapsible' => TRUE,
      '#collapsed' => !isset($start_date),
    );

    $form['scheduler']['date_start'] = array(
      '#type' => 'textfield',
      '#title' => t('Start time'),
      '#description' => t('E.g., @date', array('@date' => $now_formatted)),
      '#default_value' => isset($start_date) ? $start_date->format($format) : NULL,
    );

    $form['scheduler']['date_end_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable end date'),
      '#default_value' => isset($end_date) && $end_date->getTimestamp() > 0 ? 1 : 0,
    );

    $form['scheduler']['date_end'] = array(
      '#type' => 'textfield',
      '#title' => t('End time'),
      '#description' => t('E.g., @date', array('@date' => $now_formatted)),
      '#states' => array(
        'visible' => array(
          ':input[name="date_end_enabled"]' => array('checked' => TRUE),
        ),
      ),
      '#default_value' => isset($end_date) ? $end_date->format($format) : NULL,
    );

    // These additions/modifications to the form elements are made if the
    // date_popup module is available.
    if (module_exists('date_popup')) {
      $date_popup = array(
        '#type' => 'date_popup',
        '#date_year_range' => '0:+3',
        '#description' => NULL,
      );

      $form['scheduler']['date_start'] = array_merge($form['scheduler']['date_start'], $date_popup);
      $form['scheduler']['date_end'] = array_merge($form['scheduler']['date_end'], $date_popup);
    }
  }
}

/**
 * Additional validation handler for validating webform scheduler settings.
 */
function webform_scheduler_form_webform_configure_form_validate(&$form, &$form_state) {
  $format = _webform_scheduler_date_format();

  if (!empty($form_state['values']['date_start'])) {
    // Make a new DateObject (supplied by date_api) from the user input.
    $start_date = new DateObject($form_state['values']['date_start'] . (module_exists('date_popup') ? ':00' : ''), NULL, $format);

    // If there are any mismatches between the user input and the expected
    // format, display an error to the user with a helpful link to the
    // date_popup module to make life so much easier.
    if (isset($start_date->errors['invalid'])) {
      form_set_error('date_start', $start_date->errors['invalid'] . ' ' . (!module_exists('date_popup') ? t('Install and enable the Date Popup module included in !date_link for an easy pop-up calendar.', array('!date_link' => l('Date', 'http://drupal.org/project/date'))) : ''));
    }
    // Else, we can save the timestamp which is used by the submit handler.
    else {
      $form_state['values']['date_start_timestamp'] = $start_date->getTimestamp();
    }
  }

  if ($form_state['values']['date_end_enabled'] && !empty($form_state['values']['date_end'])) {
    $end_date = new DateObject($form_state['values']['date_end'] . (module_exists('date_popup') ? ':00' : ''), NULL, $format);

    if (isset($end_date->errors['invalid'])) {
      form_set_error('date_end', $end_date->errors['invalid'] . ' ' . (!module_exists('date_popup') ? t('Install and enable the Date Popup module included in !date_link for an easy pop-up calendar.', array('!date_link' => l('Date', 'http://drupal.org/project/date'))) : ''));
    }
    else {
      $form_state['values']['date_end_timestamp'] = $end_date->getTimestamp();
    }
  }

  // If for some reason the user selected an end date that occurs before
  // the start date, they made a mistake.
  if (isset($form_state['values']['date_start_timestamp'])
    && isset($form_state['values']['date_end_timestamp'])
    && $form_state['values']['date_end_timestamp'] <= $form_state['values']['date_start_timestamp']) {
    form_set_error('date_end', t('The end time cannot be before the start time.'));
  }
}

/**
 * Additional submit handler for saving webform scheduler settings.
 */
function webform_scheduler_form_webform_configure_form_submit(&$form, &$form_state) {
  $scheduler_settings = _webform_scheduler_webform_scheduler_settings($form['#node']->nid);

  if (empty($scheduler_settings)
    || (isset($form_state['values']['date_start_timestamp']) ? $form_state['values']['date_start_timestamp'] : 0) !== $scheduler_settings['begin']
    || (isset($form_state['values']['date_end_timestamp']) ? $form_state['values']['date_end_timestamp'] : 0) !== $scheduler_settings['end']) {
    $record = array(
      'nid' => $form['#node']->nid,
      'begin' => isset($form_state['values']['date_start_timestamp']) ? $form_state['values']['date_start_timestamp'] : 0,
      'end' => isset($form_state['values']['date_end_timestamp']) ? $form_state['values']['date_end_timestamp'] : 0,
    );

    // Insert or update the scheduler settings of this webform.
    drupal_write_record('webform_scheduler', $record, empty($scheduler_settings) ? array() : 'nid');
  }
}

/**
 * Implements hook_node_view().
 */
function webform_scheduler_node_view($node, $view_mode) {
  $scheduler_settings = _webform_scheduler_webform_scheduler_settings($node->nid);

  if (!empty($scheduler_settings)) {
    $node->webform['scheduler_start'] = (int) $scheduler_settings['begin'];
    $node->webform['scheduler_end'] = (int) $scheduler_settings['end'];

    if ((!empty($node->webform['scheduler_start']) && time() < $node->webform['scheduler_start'])
      || (!empty($node->webform['scheduler_end']) && time() > $node->webform['scheduler_end'])) {
      $node->webform['status'] = 0;
    }
  }
}

/**
 * Fetch the scheduler settings and information of webform(s) by the node ID.
 *
 * @param int $nid
 *   The node ID that the webform belongs.
 *
 * @return array
 *   A row of information represented as an associative array.
 */
function _webform_scheduler_webform_scheduler_settings($nid) {
  return db_select('webform_scheduler', 'w', array('fetch' => PDO::FETCH_ASSOC))
    ->fields('w')
    ->condition('w.nid', $nid)
    ->execute()
    ->fetchAssoc();
}

/**
 * Fetch the date/time format for this module.
 *
 * @return string
 *   A date/time format understandable by PHP's date()
 */
function _webform_scheduler_date_format() {
  return module_exists('date_popup') ? DATE_FORMAT_DATETIME : variable_get('date_format_short', 'm/d/Y - H:i');
}
