<?php
/**
 * @file
 * This module allows webforms to have a start and end date for their
 * submissions.
 *
 * @author Daniel Imhoff
 */

/**
 * Implements hook_permission().
 */
function webform_scheduler_permission() {
  return array(
    'schedule webforms' => array(
      'title' => t('Schedule webforms'),
      'description' => t('Change a webform\'s start and end date, allowing a webform to be scheduled.'),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for webform_configure_form().
 */
function webform_scheduler_form_webform_configure_form_alter(&$form, &$form_state) {
  if (user_access('schedule webforms')) {
    $settings = _webform_scheduler_webform_scheduler_settings($form['#node']->nid);

    $form['#validate'][] = 'webform_scheduler_form_webform_configure_form_validate';
    $form['#submit'][] = 'webform_scheduler_form_webform_configure_form_submit';
    $form['#attached']['css'][] = drupal_get_path('module', 'webform_scheduler') . '/webform_scheduler.admin.css';

    $format = _webform_scheduler_date_format();

    $now = new DateObject();
    $now_formatted = $now->format($format);

    if (!empty($settings)) {
      $start_date = $settings['begin'] != 0 ? new DateObject($settings['begin']) : NULL;
      $end_date = $settings['end'] != 0 ? new DateObject($settings['end']) : NULL;
    }

    $form['scheduler'] = array(
      '#type' => 'fieldset',
      '#title' => t('Scheduler'),
      '#description' => t('Specify dates and times to schedule when users are allowed to use this webform.'),
      '#weight' => -2.5,
      '#collapsible' => TRUE,
      '#collapsed' => !isset($start_date) && !isset($end_date),
      '#tree' => TRUE,
    );

    $form['scheduler']['date_start'] = array(
      '#type' => 'textfield',
      '#title' => t('Start time'),
      '#description' => t('E.g., @date', array('@date' => $now_formatted)),
      '#default_value' => isset($start_date) ? $start_date->format($format) : NULL,
    );

    $form['scheduler']['date_end'] = array(
      '#type' => 'textfield',
      '#title' => t('End time'),
      '#description' => t('E.g., @date', array('@date' => $now_formatted)),
      '#default_value' => isset($end_date) ? $end_date->format($format) : NULL,
    );

    $form['scheduler']['show_or_hide'] = array(
      '#type' => 'radios',
      '#title' => t('Access restriction method'),
      '#default_value' => isset($settings['show_or_hide']) ? (int) $settings['show_or_hide'] : 0,
      '#options' => array(
        0 => t('Hide the webform'),
        1 => t('Show the webform, but disable components'),
      ),
      '#description' => t('How should user access to the webform be restricted? Hiding the webform displays the message "Submissions for this form are closed." whereas the webform can alternatively be shown with disabled components.'),
    );

    // These additions/modifications to the form elements are made if the
    // date_popup module is available.
    if (module_exists('date_popup')) {
      $date_popup = array(
        '#type' => 'date_popup',
        '#date_year_range' => '0:+3',
        '#description' => NULL,
      );

      $form['scheduler']['date_start'] = array_merge($form['scheduler']['date_start'], $date_popup);
      $form['scheduler']['date_end'] = array_merge($form['scheduler']['date_end'], $date_popup);
    }
  }
}

/**
 * Additional validation handler for validating webform scheduler settings.
 */
function webform_scheduler_form_webform_configure_form_validate(&$form, &$form_state) {
  $values =& $form_state['values']['scheduler'];
  $format = _webform_scheduler_date_format();

  if (!empty($values['date_start'])) {
    // Make a new DateObject (supplied by date_api) from the user input.
    $start_date = new DateObject($values['date_start'] . (module_exists('date_popup') ? ':00' : ''), NULL, $format);

    // If there are any mismatches between the user input and the expected
    // format, display an error to the user with a helpful link to the
    // date_popup module to make life so much easier.
    if (isset($start_date->errors['invalid'])) {
      form_set_error('date_start', $start_date->errors['invalid'] . ' ' . (!module_exists('date_popup') ? t('Install and enable the Date Popup module included in !date_link for an easy pop-up calendar.', array('!date_link' => l('Date', 'http://drupal.org/project/date'))) : ''));
    }
    // Else, we can save the timestamp which is used by the submit handler.
    else {
      $values['date_start_timestamp'] = $start_date->format('U');
    }
  }

  if (!empty($values['date_end'])) {
    $end_date = new DateObject($values['date_end'] . (module_exists('date_popup') ? ':00' : ''), NULL, $format);

    if (isset($end_date->errors['invalid'])) {
      form_set_error('date_end', $end_date->errors['invalid'] . ' ' . (!module_exists('date_popup') ? t('Install and enable the Date Popup module included in !date_link for an easy pop-up calendar.', array('!date_link' => l('Date', 'http://drupal.org/project/date'))) : ''));
    }
    else {
      $values['date_end_timestamp'] = $end_date->format('U');
    }
  }

  // If for some reason the user selected an end date that occurs before
  // the start date, they made a mistake.
  if (isset($values['date_start_timestamp'])
    && isset($values['date_end_timestamp'])
    && $values['date_end_timestamp'] <= $values['date_start_timestamp']) {
    form_set_error('date_end', t('The end time cannot be before the start time.'));
  }
}

/**
 * Additional submit handler for saving webform scheduler settings.
 */
function webform_scheduler_form_webform_configure_form_submit(&$form, &$form_state) {
  $values =& $form_state['values']['scheduler'];
  $settings = _webform_scheduler_webform_scheduler_settings($form['#node']->nid);

  if (empty($settings) ||
    (int) $values['show_or_hide'] !== (int) $settings['show_or_hide'] ||
    (isset($values['date_start_timestamp']) ? (int) $values['date_start_timestamp'] : 0) !== (int) $settings['begin'] ||
    (isset($values['date_end_timestamp']) ? (int) $values['date_end_timestamp'] : 0) !== (int) $settings['end']) {
    $record = array(
      'nid' => $form['#node']->nid,
      'begin' => isset($values['date_start_timestamp']) ? $values['date_start_timestamp'] : 0,
      'end' => isset($values['date_end_timestamp']) ? $values['date_end_timestamp'] : 0,
      'show_or_hide' => (int) $values['show_or_hide'],
    );

    // Insert or update the scheduler settings of this webform.
    drupal_write_record('webform_scheduler', $record, empty($settings) ? array() : 'nid');
  }
}

/**
 * Implements hook_date_popup_pre_validate_alter().
 */
function webform_scheduler_date_popup_pre_validate_alter($element, &$form_state, &$input) {
  if (0 === strpos($element['#name'], 'scheduler[date_')) {
    // If date is given but time is not, give midnight as the time.
    if (!empty($input['date']) && empty($input['time'])) {
      $input['time'] = date(end(explode(' ', $element['#date_format'])), strtotime('today midnight'));
    }
  }
}

/**
 * Implements hook_node_view().
 */
function webform_scheduler_node_view($node, $view_mode) {
  if (!in_array($node->type, webform_variable_get('webform_node_types'))) {
    return;
  }

  $settings = _webform_scheduler_webform_scheduler_settings($node->nid);

  $node->webform['scheduler_start'] = isset($settings['begin']) ? (int) $settings['begin'] : 0;
  $node->webform['scheduler_end'] = isset($settings['end']) ? (int) $settings['end'] : 0;
  $node->webform['scheduler_show'] = isset($settings['show_or_hide']) && $settings['show_or_hide'] != 0;

  if (!$node->webform['scheduler_show'] && webform_scheduler_webform_disabled($node)) {
    $node->webform['status'] = 0;
  }
}

/**
 * Implements hook_form_alter().
 */
function webform_scheduler_form_alter(&$form, &$form_state) {
  if (!isset($form['#node']) || empty($form['#node']->webform) || !isset($form['submitted'])) {
    return;
  }

  if ($form['#node']->webform['status'] != 0 && $form['#node']->webform['scheduler_show'] && webform_scheduler_webform_disabled($form['#node'])) {
    $elements = array();
    _webform_scheduler_flatten_components($form['submitted'], $elements);
    _webform_scheduler_flatten_components($form['actions'], $elements);

    foreach ($elements as &$element) {
      $element['#attributes']['disabled'] = TRUE;
    }

    // Yes, this is evil. Think of a better way.
    $form['#validate'] = array();
    $form['#submit'] = array();
  }
}

/**
 * Implements hook_node_delete().
 */
function webform_scheduler_node_delete($node) {
  if (!in_array($node->type, webform_variable_get('webform_node_types'))) {
    return;
  }

  db_delete('webform_scheduler')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Checks to see if the webform is disabled or not.
 *
 * @param int $node
 *   The node stdClass to which this webform belongs.
 * @return boolean
 *   TRUE if the webform under the node ID is disabled, FALSE otherwise.
 */
function webform_scheduler_webform_disabled(&$node) {
  if (($node->webform['scheduler_start'] > 0 && REQUEST_TIME < $node->webform['scheduler_start']) ||
    ($node->webform['scheduler_end'] > 0 && REQUEST_TIME > $node->webform['scheduler_end'])) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Fetch the scheduler settings and information of webform(s) by the node ID.
 *
 * @param int $nid
 *   The node ID to which the webform belongs.
 *
 * @return array
 *   A row of information represented as an associative array.
 */
function _webform_scheduler_webform_scheduler_settings($nid) {
  return db_select('webform_scheduler', 'w', array('fetch' => PDO::FETCH_ASSOC))
    ->fields('w')
    ->condition('w.nid', $nid)
    ->execute()
    ->fetchAssoc();
}

/**
 * Fetch the date/time format for this module.
 *
 * @return string
 *   A date/time format understandable by PHP's date().
 */
function _webform_scheduler_date_format() {
  return module_exists('date_popup') ? DATE_FORMAT_DATETIME : variable_get('date_format_short', 'm/d/Y - H:i');
}

/**
 * Flattens the webform component tree into an associative array keyed by the
 * form key of the component.
 *
 * @param array $element
 *   Usually $form['submitted'].
 * @param array $elements
 *   The elements array, passed by reference to add the elements to.
 */
function _webform_scheduler_flatten_components(&$element, &$elements) {
  if (is_array($element)) {
    foreach (element_children($element) as $element_key) {
      $elements[$element_key] =& $element[$element_key];
      _webform_scheduler_flatten_components($element[$element_key], $elements);
    }
  }
}
